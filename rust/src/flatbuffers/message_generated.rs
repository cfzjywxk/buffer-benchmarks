// automatically generated by the FlatBuffers compiler, do not modify

// @generated

use core::cmp::Ordering;
use core::mem;

extern crate flatbuffers;
use self::flatbuffers::{EndianScalar, Follow};

#[allow(unused_imports, dead_code)]
pub mod farcaster {

    use core::cmp::Ordering;
    use core::mem;

    extern crate flatbuffers;
    use self::flatbuffers::{EndianScalar, Follow};

    #[deprecated(
        since = "2.0.0",
        note = "Use associated constants instead. This will no longer be generated in 2021."
    )]
    pub const ENUM_MIN_MESSAGE_TYPE: u16 = 1;
    #[deprecated(
        since = "2.0.0",
        note = "Use associated constants instead. This will no longer be generated in 2021."
    )]
    pub const ENUM_MAX_MESSAGE_TYPE: u16 = 11;
    #[deprecated(
        since = "2.0.0",
        note = "Use associated constants instead. This will no longer be generated in 2021."
    )]
    #[allow(non_camel_case_types)]
    pub const ENUM_VALUES_MESSAGE_TYPE: [MessageType; 11] = [
        MessageType::CastAdd,
        MessageType::CastRemove,
        MessageType::ReactionAdd,
        MessageType::ReactionRemove,
        MessageType::AmpAdd,
        MessageType::AmpRemove,
        MessageType::VerificationAddEthAddress,
        MessageType::VerificationRemove,
        MessageType::SignerAdd,
        MessageType::SignerRemove,
        MessageType::UserDataAdd,
    ];

    #[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
    #[repr(transparent)]
    pub struct MessageType(pub u16);
    #[allow(non_upper_case_globals)]
    impl MessageType {
        pub const CastAdd: Self = Self(1);
        pub const CastRemove: Self = Self(2);
        pub const ReactionAdd: Self = Self(3);
        pub const ReactionRemove: Self = Self(4);
        pub const AmpAdd: Self = Self(5);
        pub const AmpRemove: Self = Self(6);
        pub const VerificationAddEthAddress: Self = Self(7);
        pub const VerificationRemove: Self = Self(8);
        pub const SignerAdd: Self = Self(9);
        pub const SignerRemove: Self = Self(10);
        pub const UserDataAdd: Self = Self(11);

        pub const ENUM_MIN: u16 = 1;
        pub const ENUM_MAX: u16 = 11;
        pub const ENUM_VALUES: &'static [Self] = &[
            Self::CastAdd,
            Self::CastRemove,
            Self::ReactionAdd,
            Self::ReactionRemove,
            Self::AmpAdd,
            Self::AmpRemove,
            Self::VerificationAddEthAddress,
            Self::VerificationRemove,
            Self::SignerAdd,
            Self::SignerRemove,
            Self::UserDataAdd,
        ];
        /// Returns the variant's name or "" if unknown.
        pub fn variant_name(self) -> Option<&'static str> {
            match self {
                Self::CastAdd => Some("CastAdd"),
                Self::CastRemove => Some("CastRemove"),
                Self::ReactionAdd => Some("ReactionAdd"),
                Self::ReactionRemove => Some("ReactionRemove"),
                Self::AmpAdd => Some("AmpAdd"),
                Self::AmpRemove => Some("AmpRemove"),
                Self::VerificationAddEthAddress => Some("VerificationAddEthAddress"),
                Self::VerificationRemove => Some("VerificationRemove"),
                Self::SignerAdd => Some("SignerAdd"),
                Self::SignerRemove => Some("SignerRemove"),
                Self::UserDataAdd => Some("UserDataAdd"),
                _ => None,
            }
        }
    }
    impl core::fmt::Debug for MessageType {
        fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
            if let Some(name) = self.variant_name() {
                f.write_str(name)
            } else {
                f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
            }
        }
    }
    impl<'a> flatbuffers::Follow<'a> for MessageType {
        type Inner = Self;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            let b = flatbuffers::read_scalar_at::<u16>(buf, loc);
            Self(b)
        }
    }

    impl flatbuffers::Push for MessageType {
        type Output = MessageType;
        #[inline]
        unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
            flatbuffers::emplace_scalar::<u16>(dst, self.0);
        }
    }

    impl flatbuffers::EndianScalar for MessageType {
        type Scalar = u16;
        #[inline]
        fn to_little_endian(self) -> u16 {
            self.0.to_le()
        }
        #[inline]
        #[allow(clippy::wrong_self_convention)]
        fn from_little_endian(v: u16) -> Self {
            let b = u16::from_le(v);
            Self(b)
        }
    }

    impl<'a> flatbuffers::Verifiable for MessageType {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            u16::run_verifier(v, pos)
        }
    }

    impl flatbuffers::SimpleToVerifyInSlice for MessageType {}
    #[deprecated(
        since = "2.0.0",
        note = "Use associated constants instead. This will no longer be generated in 2021."
    )]
    pub const ENUM_MIN_SIGNATURE_SCHEME: u8 = 1;
    #[deprecated(
        since = "2.0.0",
        note = "Use associated constants instead. This will no longer be generated in 2021."
    )]
    pub const ENUM_MAX_SIGNATURE_SCHEME: u8 = 2;
    #[deprecated(
        since = "2.0.0",
        note = "Use associated constants instead. This will no longer be generated in 2021."
    )]
    #[allow(non_camel_case_types)]
    pub const ENUM_VALUES_SIGNATURE_SCHEME: [SignatureScheme; 2] =
        [SignatureScheme::Ed25519, SignatureScheme::Eip712];

    #[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
    #[repr(transparent)]
    pub struct SignatureScheme(pub u8);
    #[allow(non_upper_case_globals)]
    impl SignatureScheme {
        pub const Ed25519: Self = Self(1);
        pub const Eip712: Self = Self(2);

        pub const ENUM_MIN: u8 = 1;
        pub const ENUM_MAX: u8 = 2;
        pub const ENUM_VALUES: &'static [Self] = &[Self::Ed25519, Self::Eip712];
        /// Returns the variant's name or "" if unknown.
        pub fn variant_name(self) -> Option<&'static str> {
            match self {
                Self::Ed25519 => Some("Ed25519"),
                Self::Eip712 => Some("Eip712"),
                _ => None,
            }
        }
    }
    impl core::fmt::Debug for SignatureScheme {
        fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
            if let Some(name) = self.variant_name() {
                f.write_str(name)
            } else {
                f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
            }
        }
    }
    impl<'a> flatbuffers::Follow<'a> for SignatureScheme {
        type Inner = Self;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            let b = flatbuffers::read_scalar_at::<u8>(buf, loc);
            Self(b)
        }
    }

    impl flatbuffers::Push for SignatureScheme {
        type Output = SignatureScheme;
        #[inline]
        unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
            flatbuffers::emplace_scalar::<u8>(dst, self.0);
        }
    }

    impl flatbuffers::EndianScalar for SignatureScheme {
        type Scalar = u8;
        #[inline]
        fn to_little_endian(self) -> u8 {
            self.0.to_le()
        }
        #[inline]
        #[allow(clippy::wrong_self_convention)]
        fn from_little_endian(v: u8) -> Self {
            let b = u8::from_le(v);
            Self(b)
        }
    }

    impl<'a> flatbuffers::Verifiable for SignatureScheme {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            u8::run_verifier(v, pos)
        }
    }

    impl flatbuffers::SimpleToVerifyInSlice for SignatureScheme {}
    #[deprecated(
        since = "2.0.0",
        note = "Use associated constants instead. This will no longer be generated in 2021."
    )]
    pub const ENUM_MIN_HASH_SCHEME: u8 = 1;
    #[deprecated(
        since = "2.0.0",
        note = "Use associated constants instead. This will no longer be generated in 2021."
    )]
    pub const ENUM_MAX_HASH_SCHEME: u8 = 1;
    #[deprecated(
        since = "2.0.0",
        note = "Use associated constants instead. This will no longer be generated in 2021."
    )]
    #[allow(non_camel_case_types)]
    pub const ENUM_VALUES_HASH_SCHEME: [HashScheme; 1] = [HashScheme::Blake3];

    #[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
    #[repr(transparent)]
    pub struct HashScheme(pub u8);
    #[allow(non_upper_case_globals)]
    impl HashScheme {
        pub const Blake3: Self = Self(1);

        pub const ENUM_MIN: u8 = 1;
        pub const ENUM_MAX: u8 = 1;
        pub const ENUM_VALUES: &'static [Self] = &[Self::Blake3];
        /// Returns the variant's name or "" if unknown.
        pub fn variant_name(self) -> Option<&'static str> {
            match self {
                Self::Blake3 => Some("Blake3"),
                _ => None,
            }
        }
    }
    impl core::fmt::Debug for HashScheme {
        fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
            if let Some(name) = self.variant_name() {
                f.write_str(name)
            } else {
                f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
            }
        }
    }
    impl<'a> flatbuffers::Follow<'a> for HashScheme {
        type Inner = Self;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            let b = flatbuffers::read_scalar_at::<u8>(buf, loc);
            Self(b)
        }
    }

    impl flatbuffers::Push for HashScheme {
        type Output = HashScheme;
        #[inline]
        unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
            flatbuffers::emplace_scalar::<u8>(dst, self.0);
        }
    }

    impl flatbuffers::EndianScalar for HashScheme {
        type Scalar = u8;
        #[inline]
        fn to_little_endian(self) -> u8 {
            self.0.to_le()
        }
        #[inline]
        #[allow(clippy::wrong_self_convention)]
        fn from_little_endian(v: u8) -> Self {
            let b = u8::from_le(v);
            Self(b)
        }
    }

    impl<'a> flatbuffers::Verifiable for HashScheme {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            u8::run_verifier(v, pos)
        }
    }

    impl flatbuffers::SimpleToVerifyInSlice for HashScheme {}
    #[deprecated(
        since = "2.0.0",
        note = "Use associated constants instead. This will no longer be generated in 2021."
    )]
    pub const ENUM_MIN_FARCASTER_NETWORK: u8 = 1;
    #[deprecated(
        since = "2.0.0",
        note = "Use associated constants instead. This will no longer be generated in 2021."
    )]
    pub const ENUM_MAX_FARCASTER_NETWORK: u8 = 3;
    #[deprecated(
        since = "2.0.0",
        note = "Use associated constants instead. This will no longer be generated in 2021."
    )]
    #[allow(non_camel_case_types)]
    pub const ENUM_VALUES_FARCASTER_NETWORK: [FarcasterNetwork; 3] = [
        FarcasterNetwork::Mainnet,
        FarcasterNetwork::Testnet,
        FarcasterNetwork::Devnet,
    ];

    #[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
    #[repr(transparent)]
    pub struct FarcasterNetwork(pub u8);
    #[allow(non_upper_case_globals)]
    impl FarcasterNetwork {
        pub const Mainnet: Self = Self(1);
        pub const Testnet: Self = Self(2);
        pub const Devnet: Self = Self(3);

        pub const ENUM_MIN: u8 = 1;
        pub const ENUM_MAX: u8 = 3;
        pub const ENUM_VALUES: &'static [Self] = &[Self::Mainnet, Self::Testnet, Self::Devnet];
        /// Returns the variant's name or "" if unknown.
        pub fn variant_name(self) -> Option<&'static str> {
            match self {
                Self::Mainnet => Some("Mainnet"),
                Self::Testnet => Some("Testnet"),
                Self::Devnet => Some("Devnet"),
                _ => None,
            }
        }
    }
    impl core::fmt::Debug for FarcasterNetwork {
        fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
            if let Some(name) = self.variant_name() {
                f.write_str(name)
            } else {
                f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
            }
        }
    }
    impl<'a> flatbuffers::Follow<'a> for FarcasterNetwork {
        type Inner = Self;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            let b = flatbuffers::read_scalar_at::<u8>(buf, loc);
            Self(b)
        }
    }

    impl flatbuffers::Push for FarcasterNetwork {
        type Output = FarcasterNetwork;
        #[inline]
        unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
            flatbuffers::emplace_scalar::<u8>(dst, self.0);
        }
    }

    impl flatbuffers::EndianScalar for FarcasterNetwork {
        type Scalar = u8;
        #[inline]
        fn to_little_endian(self) -> u8 {
            self.0.to_le()
        }
        #[inline]
        #[allow(clippy::wrong_self_convention)]
        fn from_little_endian(v: u8) -> Self {
            let b = u8::from_le(v);
            Self(b)
        }
    }

    impl<'a> flatbuffers::Verifiable for FarcasterNetwork {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            u8::run_verifier(v, pos)
        }
    }

    impl flatbuffers::SimpleToVerifyInSlice for FarcasterNetwork {}
    #[deprecated(
        since = "2.0.0",
        note = "Use associated constants instead. This will no longer be generated in 2021."
    )]
    pub const ENUM_MIN_REACTION_TYPE: u16 = 1;
    #[deprecated(
        since = "2.0.0",
        note = "Use associated constants instead. This will no longer be generated in 2021."
    )]
    pub const ENUM_MAX_REACTION_TYPE: u16 = 2;
    #[deprecated(
        since = "2.0.0",
        note = "Use associated constants instead. This will no longer be generated in 2021."
    )]
    #[allow(non_camel_case_types)]
    pub const ENUM_VALUES_REACTION_TYPE: [ReactionType; 2] =
        [ReactionType::Like, ReactionType::Recast];

    #[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
    #[repr(transparent)]
    pub struct ReactionType(pub u16);
    #[allow(non_upper_case_globals)]
    impl ReactionType {
        pub const Like: Self = Self(1);
        pub const Recast: Self = Self(2);

        pub const ENUM_MIN: u16 = 1;
        pub const ENUM_MAX: u16 = 2;
        pub const ENUM_VALUES: &'static [Self] = &[Self::Like, Self::Recast];
        /// Returns the variant's name or "" if unknown.
        pub fn variant_name(self) -> Option<&'static str> {
            match self {
                Self::Like => Some("Like"),
                Self::Recast => Some("Recast"),
                _ => None,
            }
        }
    }
    impl core::fmt::Debug for ReactionType {
        fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
            if let Some(name) = self.variant_name() {
                f.write_str(name)
            } else {
                f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
            }
        }
    }
    impl<'a> flatbuffers::Follow<'a> for ReactionType {
        type Inner = Self;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            let b = flatbuffers::read_scalar_at::<u16>(buf, loc);
            Self(b)
        }
    }

    impl flatbuffers::Push for ReactionType {
        type Output = ReactionType;
        #[inline]
        unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
            flatbuffers::emplace_scalar::<u16>(dst, self.0);
        }
    }

    impl flatbuffers::EndianScalar for ReactionType {
        type Scalar = u16;
        #[inline]
        fn to_little_endian(self) -> u16 {
            self.0.to_le()
        }
        #[inline]
        #[allow(clippy::wrong_self_convention)]
        fn from_little_endian(v: u16) -> Self {
            let b = u16::from_le(v);
            Self(b)
        }
    }

    impl<'a> flatbuffers::Verifiable for ReactionType {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            u16::run_verifier(v, pos)
        }
    }

    impl flatbuffers::SimpleToVerifyInSlice for ReactionType {}
    #[deprecated(
        since = "2.0.0",
        note = "Use associated constants instead. This will no longer be generated in 2021."
    )]
    pub const ENUM_MIN_USER_DATA_TYPE: u16 = 1;
    #[deprecated(
        since = "2.0.0",
        note = "Use associated constants instead. This will no longer be generated in 2021."
    )]
    pub const ENUM_MAX_USER_DATA_TYPE: u16 = 6;
    #[deprecated(
        since = "2.0.0",
        note = "Use associated constants instead. This will no longer be generated in 2021."
    )]
    #[allow(non_camel_case_types)]
    pub const ENUM_VALUES_USER_DATA_TYPE: [UserDataType; 6] = [
        UserDataType::Pfp,
        UserDataType::Display,
        UserDataType::Bio,
        UserDataType::Location,
        UserDataType::Url,
        UserDataType::Fname,
    ];

    #[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
    #[repr(transparent)]
    pub struct UserDataType(pub u16);
    #[allow(non_upper_case_globals)]
    impl UserDataType {
        pub const Pfp: Self = Self(1);
        pub const Display: Self = Self(2);
        pub const Bio: Self = Self(3);
        pub const Location: Self = Self(4);
        pub const Url: Self = Self(5);
        pub const Fname: Self = Self(6);

        pub const ENUM_MIN: u16 = 1;
        pub const ENUM_MAX: u16 = 6;
        pub const ENUM_VALUES: &'static [Self] = &[
            Self::Pfp,
            Self::Display,
            Self::Bio,
            Self::Location,
            Self::Url,
            Self::Fname,
        ];
        /// Returns the variant's name or "" if unknown.
        pub fn variant_name(self) -> Option<&'static str> {
            match self {
                Self::Pfp => Some("Pfp"),
                Self::Display => Some("Display"),
                Self::Bio => Some("Bio"),
                Self::Location => Some("Location"),
                Self::Url => Some("Url"),
                Self::Fname => Some("Fname"),
                _ => None,
            }
        }
    }
    impl core::fmt::Debug for UserDataType {
        fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
            if let Some(name) = self.variant_name() {
                f.write_str(name)
            } else {
                f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
            }
        }
    }
    impl<'a> flatbuffers::Follow<'a> for UserDataType {
        type Inner = Self;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            let b = flatbuffers::read_scalar_at::<u16>(buf, loc);
            Self(b)
        }
    }

    impl flatbuffers::Push for UserDataType {
        type Output = UserDataType;
        #[inline]
        unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
            flatbuffers::emplace_scalar::<u16>(dst, self.0);
        }
    }

    impl flatbuffers::EndianScalar for UserDataType {
        type Scalar = u16;
        #[inline]
        fn to_little_endian(self) -> u16 {
            self.0.to_le()
        }
        #[inline]
        #[allow(clippy::wrong_self_convention)]
        fn from_little_endian(v: u16) -> Self {
            let b = u16::from_le(v);
            Self(b)
        }
    }

    impl<'a> flatbuffers::Verifiable for UserDataType {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            u16::run_verifier(v, pos)
        }
    }

    impl flatbuffers::SimpleToVerifyInSlice for UserDataType {}
    #[deprecated(
        since = "2.0.0",
        note = "Use associated constants instead. This will no longer be generated in 2021."
    )]
    pub const ENUM_MIN_TARGET_ID: u8 = 0;
    #[deprecated(
        since = "2.0.0",
        note = "Use associated constants instead. This will no longer be generated in 2021."
    )]
    pub const ENUM_MAX_TARGET_ID: u8 = 1;
    #[deprecated(
        since = "2.0.0",
        note = "Use associated constants instead. This will no longer be generated in 2021."
    )]
    #[allow(non_camel_case_types)]
    pub const ENUM_VALUES_TARGET_ID: [TargetId; 2] = [TargetId::NONE, TargetId::CastId];

    #[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
    #[repr(transparent)]
    pub struct TargetId(pub u8);
    #[allow(non_upper_case_globals)]
    impl TargetId {
        pub const NONE: Self = Self(0);
        pub const CastId: Self = Self(1);

        pub const ENUM_MIN: u8 = 0;
        pub const ENUM_MAX: u8 = 1;
        pub const ENUM_VALUES: &'static [Self] = &[Self::NONE, Self::CastId];
        /// Returns the variant's name or "" if unknown.
        pub fn variant_name(self) -> Option<&'static str> {
            match self {
                Self::NONE => Some("NONE"),
                Self::CastId => Some("CastId"),
                _ => None,
            }
        }
    }
    impl core::fmt::Debug for TargetId {
        fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
            if let Some(name) = self.variant_name() {
                f.write_str(name)
            } else {
                f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
            }
        }
    }
    impl<'a> flatbuffers::Follow<'a> for TargetId {
        type Inner = Self;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            let b = flatbuffers::read_scalar_at::<u8>(buf, loc);
            Self(b)
        }
    }

    impl flatbuffers::Push for TargetId {
        type Output = TargetId;
        #[inline]
        unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
            flatbuffers::emplace_scalar::<u8>(dst, self.0);
        }
    }

    impl flatbuffers::EndianScalar for TargetId {
        type Scalar = u8;
        #[inline]
        fn to_little_endian(self) -> u8 {
            self.0.to_le()
        }
        #[inline]
        #[allow(clippy::wrong_self_convention)]
        fn from_little_endian(v: u8) -> Self {
            let b = u8::from_le(v);
            Self(b)
        }
    }

    impl<'a> flatbuffers::Verifiable for TargetId {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            u8::run_verifier(v, pos)
        }
    }

    impl flatbuffers::SimpleToVerifyInSlice for TargetId {}
    pub struct TargetIdUnionTableOffset {}

    #[deprecated(
        since = "2.0.0",
        note = "Use associated constants instead. This will no longer be generated in 2021."
    )]
    pub const ENUM_MIN_MESSAGE_BODY: u8 = 0;
    #[deprecated(
        since = "2.0.0",
        note = "Use associated constants instead. This will no longer be generated in 2021."
    )]
    pub const ENUM_MAX_MESSAGE_BODY: u8 = 8;
    #[deprecated(
        since = "2.0.0",
        note = "Use associated constants instead. This will no longer be generated in 2021."
    )]
    #[allow(non_camel_case_types)]
    pub const ENUM_VALUES_MESSAGE_BODY: [MessageBody; 9] = [
        MessageBody::NONE,
        MessageBody::CastAddBody,
        MessageBody::CastRemoveBody,
        MessageBody::ReactionBody,
        MessageBody::AmpBody,
        MessageBody::VerificationAddEthAddressBody,
        MessageBody::VerificationRemoveBody,
        MessageBody::SignerBody,
        MessageBody::UserDataBody,
    ];

    #[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
    #[repr(transparent)]
    pub struct MessageBody(pub u8);
    #[allow(non_upper_case_globals)]
    impl MessageBody {
        pub const NONE: Self = Self(0);
        pub const CastAddBody: Self = Self(1);
        pub const CastRemoveBody: Self = Self(2);
        pub const ReactionBody: Self = Self(3);
        pub const AmpBody: Self = Self(4);
        pub const VerificationAddEthAddressBody: Self = Self(5);
        pub const VerificationRemoveBody: Self = Self(6);
        pub const SignerBody: Self = Self(7);
        pub const UserDataBody: Self = Self(8);

        pub const ENUM_MIN: u8 = 0;
        pub const ENUM_MAX: u8 = 8;
        pub const ENUM_VALUES: &'static [Self] = &[
            Self::NONE,
            Self::CastAddBody,
            Self::CastRemoveBody,
            Self::ReactionBody,
            Self::AmpBody,
            Self::VerificationAddEthAddressBody,
            Self::VerificationRemoveBody,
            Self::SignerBody,
            Self::UserDataBody,
        ];
        /// Returns the variant's name or "" if unknown.
        pub fn variant_name(self) -> Option<&'static str> {
            match self {
                Self::NONE => Some("NONE"),
                Self::CastAddBody => Some("CastAddBody"),
                Self::CastRemoveBody => Some("CastRemoveBody"),
                Self::ReactionBody => Some("ReactionBody"),
                Self::AmpBody => Some("AmpBody"),
                Self::VerificationAddEthAddressBody => Some("VerificationAddEthAddressBody"),
                Self::VerificationRemoveBody => Some("VerificationRemoveBody"),
                Self::SignerBody => Some("SignerBody"),
                Self::UserDataBody => Some("UserDataBody"),
                _ => None,
            }
        }
    }
    impl core::fmt::Debug for MessageBody {
        fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
            if let Some(name) = self.variant_name() {
                f.write_str(name)
            } else {
                f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
            }
        }
    }
    impl<'a> flatbuffers::Follow<'a> for MessageBody {
        type Inner = Self;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            let b = flatbuffers::read_scalar_at::<u8>(buf, loc);
            Self(b)
        }
    }

    impl flatbuffers::Push for MessageBody {
        type Output = MessageBody;
        #[inline]
        unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
            flatbuffers::emplace_scalar::<u8>(dst, self.0);
        }
    }

    impl flatbuffers::EndianScalar for MessageBody {
        type Scalar = u8;
        #[inline]
        fn to_little_endian(self) -> u8 {
            self.0.to_le()
        }
        #[inline]
        #[allow(clippy::wrong_self_convention)]
        fn from_little_endian(v: u8) -> Self {
            let b = u8::from_le(v);
            Self(b)
        }
    }

    impl<'a> flatbuffers::Verifiable for MessageBody {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            u8::run_verifier(v, pos)
        }
    }

    impl flatbuffers::SimpleToVerifyInSlice for MessageBody {}
    pub struct MessageBodyUnionTableOffset {}

    pub enum CastIdOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct CastId<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for CastId<'a> {
        type Inner = CastId<'a>;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table::new(buf, loc),
            }
        }
    }

    impl<'a> CastId<'a> {
        pub const VT_FID: flatbuffers::VOffsetT = 4;
        pub const VT_TS_HASH: flatbuffers::VOffsetT = 6;

        #[inline]
        pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            CastId { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
            args: &'args CastIdArgs<'args>,
        ) -> flatbuffers::WIPOffset<CastId<'bldr>> {
            let mut builder = CastIdBuilder::new(_fbb);
            if let Some(x) = args.ts_hash {
                builder.add_ts_hash(x);
            }
            if let Some(x) = args.fid {
                builder.add_fid(x);
            }
            builder.finish()
        }

        #[inline]
        pub fn fid(&self) -> flatbuffers::Vector<'a, u8> {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u8>>>(
                        CastId::VT_FID,
                        None,
                    )
                    .unwrap()
            }
        }
        #[inline]
        pub fn ts_hash(&self) -> flatbuffers::Vector<'a, u8> {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u8>>>(
                        CastId::VT_TS_HASH,
                        None,
                    )
                    .unwrap()
            }
        }
    }

    impl flatbuffers::Verifiable for CastId<'_> {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.visit_table(pos)?
                .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u8>>>(
                    "fid",
                    Self::VT_FID,
                    true,
                )?
                .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u8>>>(
                    "ts_hash",
                    Self::VT_TS_HASH,
                    true,
                )?
                .finish();
            Ok(())
        }
    }
    pub struct CastIdArgs<'a> {
        pub fid: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u8>>>,
        pub ts_hash: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u8>>>,
    }
    impl<'a> Default for CastIdArgs<'a> {
        #[inline]
        fn default() -> Self {
            CastIdArgs {
                fid: None,     // required field
                ts_hash: None, // required field
            }
        }
    }

    pub struct CastIdBuilder<'a: 'b, 'b> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b> CastIdBuilder<'a, 'b> {
        #[inline]
        pub fn add_fid(&mut self, fid: flatbuffers::WIPOffset<flatbuffers::Vector<'b, u8>>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<_>>(CastId::VT_FID, fid);
        }
        #[inline]
        pub fn add_ts_hash(
            &mut self,
            ts_hash: flatbuffers::WIPOffset<flatbuffers::Vector<'b, u8>>,
        ) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<_>>(CastId::VT_TS_HASH, ts_hash);
        }
        #[inline]
        pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> CastIdBuilder<'a, 'b> {
            let start = _fbb.start_table();
            CastIdBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<CastId<'a>> {
            let o = self.fbb_.end_table(self.start_);
            self.fbb_.required(o, CastId::VT_FID, "fid");
            self.fbb_.required(o, CastId::VT_TS_HASH, "ts_hash");
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl core::fmt::Debug for CastId<'_> {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            let mut ds = f.debug_struct("CastId");
            ds.field("fid", &self.fid());
            ds.field("ts_hash", &self.ts_hash());
            ds.finish()
        }
    }
    pub enum UserIdOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct UserId<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for UserId<'a> {
        type Inner = UserId<'a>;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table::new(buf, loc),
            }
        }
    }

    impl<'a> UserId<'a> {
        pub const VT_FID: flatbuffers::VOffsetT = 4;

        #[inline]
        pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            UserId { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
            args: &'args UserIdArgs<'args>,
        ) -> flatbuffers::WIPOffset<UserId<'bldr>> {
            let mut builder = UserIdBuilder::new(_fbb);
            if let Some(x) = args.fid {
                builder.add_fid(x);
            }
            builder.finish()
        }

        #[inline]
        pub fn fid(&self) -> flatbuffers::Vector<'a, u8> {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u8>>>(
                        UserId::VT_FID,
                        None,
                    )
                    .unwrap()
            }
        }
    }

    impl flatbuffers::Verifiable for UserId<'_> {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.visit_table(pos)?
                .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u8>>>(
                    "fid",
                    Self::VT_FID,
                    true,
                )?
                .finish();
            Ok(())
        }
    }
    pub struct UserIdArgs<'a> {
        pub fid: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u8>>>,
    }
    impl<'a> Default for UserIdArgs<'a> {
        #[inline]
        fn default() -> Self {
            UserIdArgs {
                fid: None, // required field
            }
        }
    }

    pub struct UserIdBuilder<'a: 'b, 'b> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b> UserIdBuilder<'a, 'b> {
        #[inline]
        pub fn add_fid(&mut self, fid: flatbuffers::WIPOffset<flatbuffers::Vector<'b, u8>>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<_>>(UserId::VT_FID, fid);
        }
        #[inline]
        pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> UserIdBuilder<'a, 'b> {
            let start = _fbb.start_table();
            UserIdBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<UserId<'a>> {
            let o = self.fbb_.end_table(self.start_);
            self.fbb_.required(o, UserId::VT_FID, "fid");
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl core::fmt::Debug for UserId<'_> {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            let mut ds = f.debug_struct("UserId");
            ds.field("fid", &self.fid());
            ds.finish()
        }
    }
    pub enum CastAddBodyOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct CastAddBody<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for CastAddBody<'a> {
        type Inner = CastAddBody<'a>;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table::new(buf, loc),
            }
        }
    }

    impl<'a> CastAddBody<'a> {
        pub const VT_EMBEDS: flatbuffers::VOffsetT = 4;
        pub const VT_MENTIONS: flatbuffers::VOffsetT = 6;
        pub const VT_PARENT_TYPE: flatbuffers::VOffsetT = 8;
        pub const VT_PARENT: flatbuffers::VOffsetT = 10;
        pub const VT_TEXT: flatbuffers::VOffsetT = 12;

        #[inline]
        pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            CastAddBody { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
            args: &'args CastAddBodyArgs<'args>,
        ) -> flatbuffers::WIPOffset<CastAddBody<'bldr>> {
            let mut builder = CastAddBodyBuilder::new(_fbb);
            if let Some(x) = args.text {
                builder.add_text(x);
            }
            if let Some(x) = args.parent {
                builder.add_parent(x);
            }
            if let Some(x) = args.mentions {
                builder.add_mentions(x);
            }
            if let Some(x) = args.embeds {
                builder.add_embeds(x);
            }
            builder.add_parent_type(args.parent_type);
            builder.finish()
        }

        #[inline]
        pub fn embeds(
            &self,
        ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab.get::<flatbuffers::ForwardsUOffset<
                    flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>,
                >>(CastAddBody::VT_EMBEDS, None)
            }
        }
        #[inline]
        pub fn mentions(
            &self,
        ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<UserId<'a>>>> {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab.get::<flatbuffers::ForwardsUOffset<
                    flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<UserId>>,
                >>(CastAddBody::VT_MENTIONS, None)
            }
        }
        #[inline]
        pub fn parent_type(&self) -> TargetId {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<TargetId>(CastAddBody::VT_PARENT_TYPE, Some(TargetId::NONE))
                    .unwrap()
            }
        }
        #[inline]
        pub fn parent(&self) -> Option<flatbuffers::Table<'a>> {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<flatbuffers::ForwardsUOffset<flatbuffers::Table<'a>>>(
                        CastAddBody::VT_PARENT,
                        None,
                    )
            }
        }
        #[inline]
        pub fn text(&self) -> &'a str {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<flatbuffers::ForwardsUOffset<&str>>(CastAddBody::VT_TEXT, None)
                    .unwrap()
            }
        }
        #[inline]
        #[allow(non_snake_case)]
        pub fn parent_as_cast_id(&self) -> Option<CastId<'a>> {
            if self.parent_type() == TargetId::CastId {
                self.parent().map(|t| {
                    // Safety:
                    // Created from a valid Table for this object
                    // Which contains a valid union in this slot
                    unsafe { CastId::init_from_table(t) }
                })
            } else {
                None
            }
        }
    }

    impl flatbuffers::Verifiable for CastAddBody<'_> {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.visit_table(pos)?
                .visit_field::<flatbuffers::ForwardsUOffset<
                    flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>,
                >>("embeds", Self::VT_EMBEDS, false)?
                .visit_field::<flatbuffers::ForwardsUOffset<
                    flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<UserId>>,
                >>("mentions", Self::VT_MENTIONS, false)?
                .visit_union::<TargetId, _>(
                    "parent_type",
                    Self::VT_PARENT_TYPE,
                    "parent",
                    Self::VT_PARENT,
                    false,
                    |key, v, pos| match key {
                        TargetId::CastId => v
                            .verify_union_variant::<flatbuffers::ForwardsUOffset<CastId>>(
                                "TargetId::CastId",
                                pos,
                            ),
                        _ => Ok(()),
                    },
                )?
                .visit_field::<flatbuffers::ForwardsUOffset<&str>>("text", Self::VT_TEXT, true)?
                .finish();
            Ok(())
        }
    }
    pub struct CastAddBodyArgs<'a> {
        pub embeds: Option<
            flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>,
        >,
        pub mentions: Option<
            flatbuffers::WIPOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<UserId<'a>>>,
            >,
        >,
        pub parent_type: TargetId,
        pub parent: Option<flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>>,
        pub text: Option<flatbuffers::WIPOffset<&'a str>>,
    }
    impl<'a> Default for CastAddBodyArgs<'a> {
        #[inline]
        fn default() -> Self {
            CastAddBodyArgs {
                embeds: None,
                mentions: None,
                parent_type: TargetId::NONE,
                parent: None,
                text: None, // required field
            }
        }
    }

    pub struct CastAddBodyBuilder<'a: 'b, 'b> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b> CastAddBodyBuilder<'a, 'b> {
        #[inline]
        pub fn add_embeds(
            &mut self,
            embeds: flatbuffers::WIPOffset<
                flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<&'b str>>,
            >,
        ) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<_>>(CastAddBody::VT_EMBEDS, embeds);
        }
        #[inline]
        pub fn add_mentions(
            &mut self,
            mentions: flatbuffers::WIPOffset<
                flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<UserId<'b>>>,
            >,
        ) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<_>>(CastAddBody::VT_MENTIONS, mentions);
        }
        #[inline]
        pub fn add_parent_type(&mut self, parent_type: TargetId) {
            self.fbb_.push_slot::<TargetId>(
                CastAddBody::VT_PARENT_TYPE,
                parent_type,
                TargetId::NONE,
            );
        }
        #[inline]
        pub fn add_parent(&mut self, parent: flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<_>>(CastAddBody::VT_PARENT, parent);
        }
        #[inline]
        pub fn add_text(&mut self, text: flatbuffers::WIPOffset<&'b str>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<_>>(CastAddBody::VT_TEXT, text);
        }
        #[inline]
        pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> CastAddBodyBuilder<'a, 'b> {
            let start = _fbb.start_table();
            CastAddBodyBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<CastAddBody<'a>> {
            let o = self.fbb_.end_table(self.start_);
            self.fbb_.required(o, CastAddBody::VT_TEXT, "text");
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl core::fmt::Debug for CastAddBody<'_> {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            let mut ds = f.debug_struct("CastAddBody");
            ds.field("embeds", &self.embeds());
            ds.field("mentions", &self.mentions());
            ds.field("parent_type", &self.parent_type());
            match self.parent_type() {
                TargetId::CastId => {
                    if let Some(x) = self.parent_as_cast_id() {
                        ds.field("parent", &x)
                    } else {
                        ds.field(
                            "parent",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                _ => {
                    let x: Option<()> = None;
                    ds.field("parent", &x)
                }
            };
            ds.field("text", &self.text());
            ds.finish()
        }
    }
    pub enum CastRemoveBodyOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct CastRemoveBody<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for CastRemoveBody<'a> {
        type Inner = CastRemoveBody<'a>;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table::new(buf, loc),
            }
        }
    }

    impl<'a> CastRemoveBody<'a> {
        pub const VT_TARGET_TS_HASH: flatbuffers::VOffsetT = 4;

        #[inline]
        pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            CastRemoveBody { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
            args: &'args CastRemoveBodyArgs<'args>,
        ) -> flatbuffers::WIPOffset<CastRemoveBody<'bldr>> {
            let mut builder = CastRemoveBodyBuilder::new(_fbb);
            if let Some(x) = args.target_ts_hash {
                builder.add_target_ts_hash(x);
            }
            builder.finish()
        }

        #[inline]
        pub fn target_ts_hash(&self) -> flatbuffers::Vector<'a, u8> {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u8>>>(
                        CastRemoveBody::VT_TARGET_TS_HASH,
                        None,
                    )
                    .unwrap()
            }
        }
    }

    impl flatbuffers::Verifiable for CastRemoveBody<'_> {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.visit_table(pos)?
                .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u8>>>(
                    "target_ts_hash",
                    Self::VT_TARGET_TS_HASH,
                    true,
                )?
                .finish();
            Ok(())
        }
    }
    pub struct CastRemoveBodyArgs<'a> {
        pub target_ts_hash: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u8>>>,
    }
    impl<'a> Default for CastRemoveBodyArgs<'a> {
        #[inline]
        fn default() -> Self {
            CastRemoveBodyArgs {
                target_ts_hash: None, // required field
            }
        }
    }

    pub struct CastRemoveBodyBuilder<'a: 'b, 'b> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b> CastRemoveBodyBuilder<'a, 'b> {
        #[inline]
        pub fn add_target_ts_hash(
            &mut self,
            target_ts_hash: flatbuffers::WIPOffset<flatbuffers::Vector<'b, u8>>,
        ) {
            self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
                CastRemoveBody::VT_TARGET_TS_HASH,
                target_ts_hash,
            );
        }
        #[inline]
        pub fn new(
            _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        ) -> CastRemoveBodyBuilder<'a, 'b> {
            let start = _fbb.start_table();
            CastRemoveBodyBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<CastRemoveBody<'a>> {
            let o = self.fbb_.end_table(self.start_);
            self.fbb_
                .required(o, CastRemoveBody::VT_TARGET_TS_HASH, "target_ts_hash");
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl core::fmt::Debug for CastRemoveBody<'_> {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            let mut ds = f.debug_struct("CastRemoveBody");
            ds.field("target_ts_hash", &self.target_ts_hash());
            ds.finish()
        }
    }
    pub enum ReactionBodyOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct ReactionBody<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for ReactionBody<'a> {
        type Inner = ReactionBody<'a>;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table::new(buf, loc),
            }
        }
    }

    impl<'a> ReactionBody<'a> {
        pub const VT_TARGET_TYPE: flatbuffers::VOffsetT = 4;
        pub const VT_TARGET: flatbuffers::VOffsetT = 6;
        pub const VT_TYPE_: flatbuffers::VOffsetT = 8;

        #[inline]
        pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            ReactionBody { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
            args: &'args ReactionBodyArgs,
        ) -> flatbuffers::WIPOffset<ReactionBody<'bldr>> {
            let mut builder = ReactionBodyBuilder::new(_fbb);
            if let Some(x) = args.target {
                builder.add_target(x);
            }
            builder.add_type_(args.type_);
            builder.add_target_type(args.target_type);
            builder.finish()
        }

        #[inline]
        pub fn target_type(&self) -> TargetId {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<TargetId>(ReactionBody::VT_TARGET_TYPE, Some(TargetId::NONE))
                    .unwrap()
            }
        }
        #[inline]
        pub fn target(&self) -> flatbuffers::Table<'a> {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<flatbuffers::ForwardsUOffset<flatbuffers::Table<'a>>>(
                        ReactionBody::VT_TARGET,
                        None,
                    )
                    .unwrap()
            }
        }
        #[inline]
        pub fn type_(&self) -> ReactionType {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<ReactionType>(ReactionBody::VT_TYPE_, Some(ReactionType::Like))
                    .unwrap()
            }
        }
        #[inline]
        #[allow(non_snake_case)]
        pub fn target_as_cast_id(&self) -> Option<CastId<'a>> {
            if self.target_type() == TargetId::CastId {
                let u = self.target();
                // Safety:
                // Created from a valid Table for this object
                // Which contains a valid union in this slot
                Some(unsafe { CastId::init_from_table(u) })
            } else {
                None
            }
        }
    }

    impl flatbuffers::Verifiable for ReactionBody<'_> {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.visit_table(pos)?
                .visit_union::<TargetId, _>(
                    "target_type",
                    Self::VT_TARGET_TYPE,
                    "target",
                    Self::VT_TARGET,
                    true,
                    |key, v, pos| match key {
                        TargetId::CastId => v
                            .verify_union_variant::<flatbuffers::ForwardsUOffset<CastId>>(
                                "TargetId::CastId",
                                pos,
                            ),
                        _ => Ok(()),
                    },
                )?
                .visit_field::<ReactionType>("type_", Self::VT_TYPE_, false)?
                .finish();
            Ok(())
        }
    }
    pub struct ReactionBodyArgs {
        pub target_type: TargetId,
        pub target: Option<flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>>,
        pub type_: ReactionType,
    }
    impl<'a> Default for ReactionBodyArgs {
        #[inline]
        fn default() -> Self {
            ReactionBodyArgs {
                target_type: TargetId::NONE,
                target: None, // required field
                type_: ReactionType::Like,
            }
        }
    }

    pub struct ReactionBodyBuilder<'a: 'b, 'b> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b> ReactionBodyBuilder<'a, 'b> {
        #[inline]
        pub fn add_target_type(&mut self, target_type: TargetId) {
            self.fbb_.push_slot::<TargetId>(
                ReactionBody::VT_TARGET_TYPE,
                target_type,
                TargetId::NONE,
            );
        }
        #[inline]
        pub fn add_target(&mut self, target: flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<_>>(ReactionBody::VT_TARGET, target);
        }
        #[inline]
        pub fn add_type_(&mut self, type_: ReactionType) {
            self.fbb_
                .push_slot::<ReactionType>(ReactionBody::VT_TYPE_, type_, ReactionType::Like);
        }
        #[inline]
        pub fn new(
            _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        ) -> ReactionBodyBuilder<'a, 'b> {
            let start = _fbb.start_table();
            ReactionBodyBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<ReactionBody<'a>> {
            let o = self.fbb_.end_table(self.start_);
            self.fbb_.required(o, ReactionBody::VT_TARGET, "target");
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl core::fmt::Debug for ReactionBody<'_> {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            let mut ds = f.debug_struct("ReactionBody");
            ds.field("target_type", &self.target_type());
            match self.target_type() {
                TargetId::CastId => {
                    if let Some(x) = self.target_as_cast_id() {
                        ds.field("target", &x)
                    } else {
                        ds.field(
                            "target",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                _ => {
                    let x: Option<()> = None;
                    ds.field("target", &x)
                }
            };
            ds.field("type_", &self.type_());
            ds.finish()
        }
    }
    pub enum AmpBodyOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct AmpBody<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for AmpBody<'a> {
        type Inner = AmpBody<'a>;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table::new(buf, loc),
            }
        }
    }

    impl<'a> AmpBody<'a> {
        pub const VT_USER: flatbuffers::VOffsetT = 4;

        #[inline]
        pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            AmpBody { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
            args: &'args AmpBodyArgs<'args>,
        ) -> flatbuffers::WIPOffset<AmpBody<'bldr>> {
            let mut builder = AmpBodyBuilder::new(_fbb);
            if let Some(x) = args.user {
                builder.add_user(x);
            }
            builder.finish()
        }

        #[inline]
        pub fn user(&self) -> UserId<'a> {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<flatbuffers::ForwardsUOffset<UserId>>(AmpBody::VT_USER, None)
                    .unwrap()
            }
        }
    }

    impl flatbuffers::Verifiable for AmpBody<'_> {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.visit_table(pos)?
                .visit_field::<flatbuffers::ForwardsUOffset<UserId>>("user", Self::VT_USER, true)?
                .finish();
            Ok(())
        }
    }
    pub struct AmpBodyArgs<'a> {
        pub user: Option<flatbuffers::WIPOffset<UserId<'a>>>,
    }
    impl<'a> Default for AmpBodyArgs<'a> {
        #[inline]
        fn default() -> Self {
            AmpBodyArgs {
                user: None, // required field
            }
        }
    }

    pub struct AmpBodyBuilder<'a: 'b, 'b> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b> AmpBodyBuilder<'a, 'b> {
        #[inline]
        pub fn add_user(&mut self, user: flatbuffers::WIPOffset<UserId<'b>>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<UserId>>(AmpBody::VT_USER, user);
        }
        #[inline]
        pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> AmpBodyBuilder<'a, 'b> {
            let start = _fbb.start_table();
            AmpBodyBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<AmpBody<'a>> {
            let o = self.fbb_.end_table(self.start_);
            self.fbb_.required(o, AmpBody::VT_USER, "user");
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl core::fmt::Debug for AmpBody<'_> {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            let mut ds = f.debug_struct("AmpBody");
            ds.field("user", &self.user());
            ds.finish()
        }
    }
    pub enum VerificationAddEthAddressBodyOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct VerificationAddEthAddressBody<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for VerificationAddEthAddressBody<'a> {
        type Inner = VerificationAddEthAddressBody<'a>;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table::new(buf, loc),
            }
        }
    }

    impl<'a> VerificationAddEthAddressBody<'a> {
        pub const VT_ADDRESS: flatbuffers::VOffsetT = 4;
        pub const VT_ETH_SIGNATURE: flatbuffers::VOffsetT = 6;
        pub const VT_BLOCK_HASH: flatbuffers::VOffsetT = 8;

        #[inline]
        pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            VerificationAddEthAddressBody { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
            args: &'args VerificationAddEthAddressBodyArgs<'args>,
        ) -> flatbuffers::WIPOffset<VerificationAddEthAddressBody<'bldr>> {
            let mut builder = VerificationAddEthAddressBodyBuilder::new(_fbb);
            if let Some(x) = args.block_hash {
                builder.add_block_hash(x);
            }
            if let Some(x) = args.eth_signature {
                builder.add_eth_signature(x);
            }
            if let Some(x) = args.address {
                builder.add_address(x);
            }
            builder.finish()
        }

        #[inline]
        pub fn address(&self) -> flatbuffers::Vector<'a, u8> {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u8>>>(
                        VerificationAddEthAddressBody::VT_ADDRESS,
                        None,
                    )
                    .unwrap()
            }
        }
        #[inline]
        pub fn eth_signature(&self) -> flatbuffers::Vector<'a, u8> {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u8>>>(
                        VerificationAddEthAddressBody::VT_ETH_SIGNATURE,
                        None,
                    )
                    .unwrap()
            }
        }
        #[inline]
        pub fn block_hash(&self) -> flatbuffers::Vector<'a, u8> {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u8>>>(
                        VerificationAddEthAddressBody::VT_BLOCK_HASH,
                        None,
                    )
                    .unwrap()
            }
        }
    }

    impl flatbuffers::Verifiable for VerificationAddEthAddressBody<'_> {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.visit_table(pos)?
                .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u8>>>(
                    "address",
                    Self::VT_ADDRESS,
                    true,
                )?
                .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u8>>>(
                    "eth_signature",
                    Self::VT_ETH_SIGNATURE,
                    true,
                )?
                .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u8>>>(
                    "block_hash",
                    Self::VT_BLOCK_HASH,
                    true,
                )?
                .finish();
            Ok(())
        }
    }
    pub struct VerificationAddEthAddressBodyArgs<'a> {
        pub address: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u8>>>,
        pub eth_signature: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u8>>>,
        pub block_hash: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u8>>>,
    }
    impl<'a> Default for VerificationAddEthAddressBodyArgs<'a> {
        #[inline]
        fn default() -> Self {
            VerificationAddEthAddressBodyArgs {
                address: None,       // required field
                eth_signature: None, // required field
                block_hash: None,    // required field
            }
        }
    }

    pub struct VerificationAddEthAddressBodyBuilder<'a: 'b, 'b> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b> VerificationAddEthAddressBodyBuilder<'a, 'b> {
        #[inline]
        pub fn add_address(
            &mut self,
            address: flatbuffers::WIPOffset<flatbuffers::Vector<'b, u8>>,
        ) {
            self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
                VerificationAddEthAddressBody::VT_ADDRESS,
                address,
            );
        }
        #[inline]
        pub fn add_eth_signature(
            &mut self,
            eth_signature: flatbuffers::WIPOffset<flatbuffers::Vector<'b, u8>>,
        ) {
            self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
                VerificationAddEthAddressBody::VT_ETH_SIGNATURE,
                eth_signature,
            );
        }
        #[inline]
        pub fn add_block_hash(
            &mut self,
            block_hash: flatbuffers::WIPOffset<flatbuffers::Vector<'b, u8>>,
        ) {
            self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
                VerificationAddEthAddressBody::VT_BLOCK_HASH,
                block_hash,
            );
        }
        #[inline]
        pub fn new(
            _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        ) -> VerificationAddEthAddressBodyBuilder<'a, 'b> {
            let start = _fbb.start_table();
            VerificationAddEthAddressBodyBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<VerificationAddEthAddressBody<'a>> {
            let o = self.fbb_.end_table(self.start_);
            self.fbb_
                .required(o, VerificationAddEthAddressBody::VT_ADDRESS, "address");
            self.fbb_.required(
                o,
                VerificationAddEthAddressBody::VT_ETH_SIGNATURE,
                "eth_signature",
            );
            self.fbb_.required(
                o,
                VerificationAddEthAddressBody::VT_BLOCK_HASH,
                "block_hash",
            );
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl core::fmt::Debug for VerificationAddEthAddressBody<'_> {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            let mut ds = f.debug_struct("VerificationAddEthAddressBody");
            ds.field("address", &self.address());
            ds.field("eth_signature", &self.eth_signature());
            ds.field("block_hash", &self.block_hash());
            ds.finish()
        }
    }
    pub enum VerificationRemoveBodyOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct VerificationRemoveBody<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for VerificationRemoveBody<'a> {
        type Inner = VerificationRemoveBody<'a>;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table::new(buf, loc),
            }
        }
    }

    impl<'a> VerificationRemoveBody<'a> {
        pub const VT_ADDRESS: flatbuffers::VOffsetT = 4;

        #[inline]
        pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            VerificationRemoveBody { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
            args: &'args VerificationRemoveBodyArgs<'args>,
        ) -> flatbuffers::WIPOffset<VerificationRemoveBody<'bldr>> {
            let mut builder = VerificationRemoveBodyBuilder::new(_fbb);
            if let Some(x) = args.address {
                builder.add_address(x);
            }
            builder.finish()
        }

        #[inline]
        pub fn address(&self) -> flatbuffers::Vector<'a, u8> {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u8>>>(
                        VerificationRemoveBody::VT_ADDRESS,
                        None,
                    )
                    .unwrap()
            }
        }
    }

    impl flatbuffers::Verifiable for VerificationRemoveBody<'_> {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.visit_table(pos)?
                .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u8>>>(
                    "address",
                    Self::VT_ADDRESS,
                    true,
                )?
                .finish();
            Ok(())
        }
    }
    pub struct VerificationRemoveBodyArgs<'a> {
        pub address: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u8>>>,
    }
    impl<'a> Default for VerificationRemoveBodyArgs<'a> {
        #[inline]
        fn default() -> Self {
            VerificationRemoveBodyArgs {
                address: None, // required field
            }
        }
    }

    pub struct VerificationRemoveBodyBuilder<'a: 'b, 'b> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b> VerificationRemoveBodyBuilder<'a, 'b> {
        #[inline]
        pub fn add_address(
            &mut self,
            address: flatbuffers::WIPOffset<flatbuffers::Vector<'b, u8>>,
        ) {
            self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
                VerificationRemoveBody::VT_ADDRESS,
                address,
            );
        }
        #[inline]
        pub fn new(
            _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        ) -> VerificationRemoveBodyBuilder<'a, 'b> {
            let start = _fbb.start_table();
            VerificationRemoveBodyBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<VerificationRemoveBody<'a>> {
            let o = self.fbb_.end_table(self.start_);
            self.fbb_
                .required(o, VerificationRemoveBody::VT_ADDRESS, "address");
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl core::fmt::Debug for VerificationRemoveBody<'_> {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            let mut ds = f.debug_struct("VerificationRemoveBody");
            ds.field("address", &self.address());
            ds.finish()
        }
    }
    pub enum SignerBodyOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct SignerBody<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for SignerBody<'a> {
        type Inner = SignerBody<'a>;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table::new(buf, loc),
            }
        }
    }

    impl<'a> SignerBody<'a> {
        pub const VT_SIGNER: flatbuffers::VOffsetT = 4;

        #[inline]
        pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            SignerBody { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
            args: &'args SignerBodyArgs<'args>,
        ) -> flatbuffers::WIPOffset<SignerBody<'bldr>> {
            let mut builder = SignerBodyBuilder::new(_fbb);
            if let Some(x) = args.signer {
                builder.add_signer(x);
            }
            builder.finish()
        }

        #[inline]
        pub fn signer(&self) -> flatbuffers::Vector<'a, u8> {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u8>>>(
                        SignerBody::VT_SIGNER,
                        None,
                    )
                    .unwrap()
            }
        }
    }

    impl flatbuffers::Verifiable for SignerBody<'_> {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.visit_table(pos)?
                .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u8>>>(
                    "signer",
                    Self::VT_SIGNER,
                    true,
                )?
                .finish();
            Ok(())
        }
    }
    pub struct SignerBodyArgs<'a> {
        pub signer: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u8>>>,
    }
    impl<'a> Default for SignerBodyArgs<'a> {
        #[inline]
        fn default() -> Self {
            SignerBodyArgs {
                signer: None, // required field
            }
        }
    }

    pub struct SignerBodyBuilder<'a: 'b, 'b> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b> SignerBodyBuilder<'a, 'b> {
        #[inline]
        pub fn add_signer(&mut self, signer: flatbuffers::WIPOffset<flatbuffers::Vector<'b, u8>>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<_>>(SignerBody::VT_SIGNER, signer);
        }
        #[inline]
        pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> SignerBodyBuilder<'a, 'b> {
            let start = _fbb.start_table();
            SignerBodyBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<SignerBody<'a>> {
            let o = self.fbb_.end_table(self.start_);
            self.fbb_.required(o, SignerBody::VT_SIGNER, "signer");
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl core::fmt::Debug for SignerBody<'_> {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            let mut ds = f.debug_struct("SignerBody");
            ds.field("signer", &self.signer());
            ds.finish()
        }
    }
    pub enum UserDataBodyOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct UserDataBody<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for UserDataBody<'a> {
        type Inner = UserDataBody<'a>;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table::new(buf, loc),
            }
        }
    }

    impl<'a> UserDataBody<'a> {
        pub const VT_TYPE_: flatbuffers::VOffsetT = 4;
        pub const VT_VALUE: flatbuffers::VOffsetT = 6;

        #[inline]
        pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            UserDataBody { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
            args: &'args UserDataBodyArgs<'args>,
        ) -> flatbuffers::WIPOffset<UserDataBody<'bldr>> {
            let mut builder = UserDataBodyBuilder::new(_fbb);
            if let Some(x) = args.value {
                builder.add_value(x);
            }
            builder.add_type_(args.type_);
            builder.finish()
        }

        #[inline]
        pub fn type_(&self) -> UserDataType {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<UserDataType>(UserDataBody::VT_TYPE_, Some(UserDataType::Pfp))
                    .unwrap()
            }
        }
        #[inline]
        pub fn value(&self) -> Option<&'a str> {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<flatbuffers::ForwardsUOffset<&str>>(UserDataBody::VT_VALUE, None)
            }
        }
    }

    impl flatbuffers::Verifiable for UserDataBody<'_> {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.visit_table(pos)?
                .visit_field::<UserDataType>("type_", Self::VT_TYPE_, false)?
                .visit_field::<flatbuffers::ForwardsUOffset<&str>>("value", Self::VT_VALUE, false)?
                .finish();
            Ok(())
        }
    }
    pub struct UserDataBodyArgs<'a> {
        pub type_: UserDataType,
        pub value: Option<flatbuffers::WIPOffset<&'a str>>,
    }
    impl<'a> Default for UserDataBodyArgs<'a> {
        #[inline]
        fn default() -> Self {
            UserDataBodyArgs {
                type_: UserDataType::Pfp,
                value: None,
            }
        }
    }

    pub struct UserDataBodyBuilder<'a: 'b, 'b> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b> UserDataBodyBuilder<'a, 'b> {
        #[inline]
        pub fn add_type_(&mut self, type_: UserDataType) {
            self.fbb_
                .push_slot::<UserDataType>(UserDataBody::VT_TYPE_, type_, UserDataType::Pfp);
        }
        #[inline]
        pub fn add_value(&mut self, value: flatbuffers::WIPOffset<&'b str>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<_>>(UserDataBody::VT_VALUE, value);
        }
        #[inline]
        pub fn new(
            _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        ) -> UserDataBodyBuilder<'a, 'b> {
            let start = _fbb.start_table();
            UserDataBodyBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<UserDataBody<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl core::fmt::Debug for UserDataBody<'_> {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            let mut ds = f.debug_struct("UserDataBody");
            ds.field("type_", &self.type_());
            ds.field("value", &self.value());
            ds.finish()
        }
    }
    pub enum MessageDataOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct MessageData<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for MessageData<'a> {
        type Inner = MessageData<'a>;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table::new(buf, loc),
            }
        }
    }

    impl<'a> MessageData<'a> {
        pub const VT_BODY_TYPE: flatbuffers::VOffsetT = 4;
        pub const VT_BODY: flatbuffers::VOffsetT = 6;
        pub const VT_TYPE_: flatbuffers::VOffsetT = 8;
        pub const VT_TIMESTAMP: flatbuffers::VOffsetT = 10;
        pub const VT_FID: flatbuffers::VOffsetT = 12;
        pub const VT_NETWORK: flatbuffers::VOffsetT = 14;

        #[inline]
        pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            MessageData { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
            args: &'args MessageDataArgs<'args>,
        ) -> flatbuffers::WIPOffset<MessageData<'bldr>> {
            let mut builder = MessageDataBuilder::new(_fbb);
            if let Some(x) = args.fid {
                builder.add_fid(x);
            }
            builder.add_timestamp(args.timestamp);
            if let Some(x) = args.body {
                builder.add_body(x);
            }
            if let Some(x) = args.type_ {
                builder.add_type_(x);
            }
            builder.add_network(args.network);
            builder.add_body_type(args.body_type);
            builder.finish()
        }

        #[inline]
        pub fn body_type(&self) -> MessageBody {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<MessageBody>(MessageData::VT_BODY_TYPE, Some(MessageBody::NONE))
                    .unwrap()
            }
        }
        #[inline]
        pub fn body(&self) -> flatbuffers::Table<'a> {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<flatbuffers::ForwardsUOffset<flatbuffers::Table<'a>>>(
                        MessageData::VT_BODY,
                        None,
                    )
                    .unwrap()
            }
        }
        #[inline]
        pub fn type_(&self) -> Option<MessageType> {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe { self._tab.get::<MessageType>(MessageData::VT_TYPE_, None) }
        }
        #[inline]
        pub fn timestamp(&self) -> u32 {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<u32>(MessageData::VT_TIMESTAMP, Some(0))
                    .unwrap()
            }
        }
        #[inline]
        pub fn fid(&self) -> flatbuffers::Vector<'a, u8> {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u8>>>(
                        MessageData::VT_FID,
                        None,
                    )
                    .unwrap()
            }
        }
        #[inline]
        pub fn network(&self) -> FarcasterNetwork {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<FarcasterNetwork>(
                        MessageData::VT_NETWORK,
                        Some(FarcasterNetwork::Mainnet),
                    )
                    .unwrap()
            }
        }
        #[inline]
        #[allow(non_snake_case)]
        pub fn body_as_cast_add_body(&self) -> Option<CastAddBody<'a>> {
            if self.body_type() == MessageBody::CastAddBody {
                let u = self.body();
                // Safety:
                // Created from a valid Table for this object
                // Which contains a valid union in this slot
                Some(unsafe { CastAddBody::init_from_table(u) })
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn body_as_cast_remove_body(&self) -> Option<CastRemoveBody<'a>> {
            if self.body_type() == MessageBody::CastRemoveBody {
                let u = self.body();
                // Safety:
                // Created from a valid Table for this object
                // Which contains a valid union in this slot
                Some(unsafe { CastRemoveBody::init_from_table(u) })
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn body_as_reaction_body(&self) -> Option<ReactionBody<'a>> {
            if self.body_type() == MessageBody::ReactionBody {
                let u = self.body();
                // Safety:
                // Created from a valid Table for this object
                // Which contains a valid union in this slot
                Some(unsafe { ReactionBody::init_from_table(u) })
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn body_as_amp_body(&self) -> Option<AmpBody<'a>> {
            if self.body_type() == MessageBody::AmpBody {
                let u = self.body();
                // Safety:
                // Created from a valid Table for this object
                // Which contains a valid union in this slot
                Some(unsafe { AmpBody::init_from_table(u) })
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn body_as_verification_add_eth_address_body(
            &self,
        ) -> Option<VerificationAddEthAddressBody<'a>> {
            if self.body_type() == MessageBody::VerificationAddEthAddressBody {
                let u = self.body();
                // Safety:
                // Created from a valid Table for this object
                // Which contains a valid union in this slot
                Some(unsafe { VerificationAddEthAddressBody::init_from_table(u) })
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn body_as_verification_remove_body(&self) -> Option<VerificationRemoveBody<'a>> {
            if self.body_type() == MessageBody::VerificationRemoveBody {
                let u = self.body();
                // Safety:
                // Created from a valid Table for this object
                // Which contains a valid union in this slot
                Some(unsafe { VerificationRemoveBody::init_from_table(u) })
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn body_as_signer_body(&self) -> Option<SignerBody<'a>> {
            if self.body_type() == MessageBody::SignerBody {
                let u = self.body();
                // Safety:
                // Created from a valid Table for this object
                // Which contains a valid union in this slot
                Some(unsafe { SignerBody::init_from_table(u) })
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn body_as_user_data_body(&self) -> Option<UserDataBody<'a>> {
            if self.body_type() == MessageBody::UserDataBody {
                let u = self.body();
                // Safety:
                // Created from a valid Table for this object
                // Which contains a valid union in this slot
                Some(unsafe { UserDataBody::init_from_table(u) })
            } else {
                None
            }
        }
    }

    impl flatbuffers::Verifiable for MessageData<'_> {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.visit_table(pos)?
     .visit_union::<MessageBody, _>("body_type", Self::VT_BODY_TYPE, "body", Self::VT_BODY, true, |key, v, pos| {
        match key {
          MessageBody::CastAddBody => v.verify_union_variant::<flatbuffers::ForwardsUOffset<CastAddBody>>("MessageBody::CastAddBody", pos),
          MessageBody::CastRemoveBody => v.verify_union_variant::<flatbuffers::ForwardsUOffset<CastRemoveBody>>("MessageBody::CastRemoveBody", pos),
          MessageBody::ReactionBody => v.verify_union_variant::<flatbuffers::ForwardsUOffset<ReactionBody>>("MessageBody::ReactionBody", pos),
          MessageBody::AmpBody => v.verify_union_variant::<flatbuffers::ForwardsUOffset<AmpBody>>("MessageBody::AmpBody", pos),
          MessageBody::VerificationAddEthAddressBody => v.verify_union_variant::<flatbuffers::ForwardsUOffset<VerificationAddEthAddressBody>>("MessageBody::VerificationAddEthAddressBody", pos),
          MessageBody::VerificationRemoveBody => v.verify_union_variant::<flatbuffers::ForwardsUOffset<VerificationRemoveBody>>("MessageBody::VerificationRemoveBody", pos),
          MessageBody::SignerBody => v.verify_union_variant::<flatbuffers::ForwardsUOffset<SignerBody>>("MessageBody::SignerBody", pos),
          MessageBody::UserDataBody => v.verify_union_variant::<flatbuffers::ForwardsUOffset<UserDataBody>>("MessageBody::UserDataBody", pos),
          _ => Ok(()),
        }
     })?
     .visit_field::<MessageType>("type_", Self::VT_TYPE_, false)?
     .visit_field::<u32>("timestamp", Self::VT_TIMESTAMP, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u8>>>("fid", Self::VT_FID, true)?
     .visit_field::<FarcasterNetwork>("network", Self::VT_NETWORK, false)?
     .finish();
            Ok(())
        }
    }
    pub struct MessageDataArgs<'a> {
        pub body_type: MessageBody,
        pub body: Option<flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>>,
        pub type_: Option<MessageType>,
        pub timestamp: u32,
        pub fid: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u8>>>,
        pub network: FarcasterNetwork,
    }
    impl<'a> Default for MessageDataArgs<'a> {
        #[inline]
        fn default() -> Self {
            MessageDataArgs {
                body_type: MessageBody::NONE,
                body: None, // required field
                type_: None,
                timestamp: 0,
                fid: None, // required field
                network: FarcasterNetwork::Mainnet,
            }
        }
    }

    pub struct MessageDataBuilder<'a: 'b, 'b> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b> MessageDataBuilder<'a, 'b> {
        #[inline]
        pub fn add_body_type(&mut self, body_type: MessageBody) {
            self.fbb_.push_slot::<MessageBody>(
                MessageData::VT_BODY_TYPE,
                body_type,
                MessageBody::NONE,
            );
        }
        #[inline]
        pub fn add_body(&mut self, body: flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<_>>(MessageData::VT_BODY, body);
        }
        #[inline]
        pub fn add_type_(&mut self, type_: MessageType) {
            self.fbb_
                .push_slot_always::<MessageType>(MessageData::VT_TYPE_, type_);
        }
        #[inline]
        pub fn add_timestamp(&mut self, timestamp: u32) {
            self.fbb_
                .push_slot::<u32>(MessageData::VT_TIMESTAMP, timestamp, 0);
        }
        #[inline]
        pub fn add_fid(&mut self, fid: flatbuffers::WIPOffset<flatbuffers::Vector<'b, u8>>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<_>>(MessageData::VT_FID, fid);
        }
        #[inline]
        pub fn add_network(&mut self, network: FarcasterNetwork) {
            self.fbb_.push_slot::<FarcasterNetwork>(
                MessageData::VT_NETWORK,
                network,
                FarcasterNetwork::Mainnet,
            );
        }
        #[inline]
        pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> MessageDataBuilder<'a, 'b> {
            let start = _fbb.start_table();
            MessageDataBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<MessageData<'a>> {
            let o = self.fbb_.end_table(self.start_);
            self.fbb_.required(o, MessageData::VT_BODY, "body");
            self.fbb_.required(o, MessageData::VT_FID, "fid");
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl core::fmt::Debug for MessageData<'_> {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            let mut ds = f.debug_struct("MessageData");
            ds.field("body_type", &self.body_type());
            match self.body_type() {
                MessageBody::CastAddBody => {
                    if let Some(x) = self.body_as_cast_add_body() {
                        ds.field("body", &x)
                    } else {
                        ds.field(
                            "body",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                MessageBody::CastRemoveBody => {
                    if let Some(x) = self.body_as_cast_remove_body() {
                        ds.field("body", &x)
                    } else {
                        ds.field(
                            "body",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                MessageBody::ReactionBody => {
                    if let Some(x) = self.body_as_reaction_body() {
                        ds.field("body", &x)
                    } else {
                        ds.field(
                            "body",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                MessageBody::AmpBody => {
                    if let Some(x) = self.body_as_amp_body() {
                        ds.field("body", &x)
                    } else {
                        ds.field(
                            "body",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                MessageBody::VerificationAddEthAddressBody => {
                    if let Some(x) = self.body_as_verification_add_eth_address_body() {
                        ds.field("body", &x)
                    } else {
                        ds.field(
                            "body",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                MessageBody::VerificationRemoveBody => {
                    if let Some(x) = self.body_as_verification_remove_body() {
                        ds.field("body", &x)
                    } else {
                        ds.field(
                            "body",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                MessageBody::SignerBody => {
                    if let Some(x) = self.body_as_signer_body() {
                        ds.field("body", &x)
                    } else {
                        ds.field(
                            "body",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                MessageBody::UserDataBody => {
                    if let Some(x) = self.body_as_user_data_body() {
                        ds.field("body", &x)
                    } else {
                        ds.field(
                            "body",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                _ => {
                    let x: Option<()> = None;
                    ds.field("body", &x)
                }
            };
            ds.field("type_", &self.type_());
            ds.field("timestamp", &self.timestamp());
            ds.field("fid", &self.fid());
            ds.field("network", &self.network());
            ds.finish()
        }
    }
    pub enum MessageOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct Message<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for Message<'a> {
        type Inner = Message<'a>;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table::new(buf, loc),
            }
        }
    }

    impl<'a> Message<'a> {
        pub const VT_DATA: flatbuffers::VOffsetT = 4;
        pub const VT_HASH: flatbuffers::VOffsetT = 6;
        pub const VT_HASH_SCHEME: flatbuffers::VOffsetT = 8;
        pub const VT_SIGNATURE: flatbuffers::VOffsetT = 10;
        pub const VT_SIGNATURE_SCHEME: flatbuffers::VOffsetT = 12;
        pub const VT_SIGNER: flatbuffers::VOffsetT = 14;

        #[inline]
        pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            Message { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
            args: &'args MessageArgs<'args>,
        ) -> flatbuffers::WIPOffset<Message<'bldr>> {
            let mut builder = MessageBuilder::new(_fbb);
            if let Some(x) = args.signer {
                builder.add_signer(x);
            }
            if let Some(x) = args.signature {
                builder.add_signature(x);
            }
            if let Some(x) = args.hash {
                builder.add_hash(x);
            }
            if let Some(x) = args.data {
                builder.add_data(x);
            }
            builder.add_signature_scheme(args.signature_scheme);
            builder.add_hash_scheme(args.hash_scheme);
            builder.finish()
        }

        #[inline]
        pub fn data(&self) -> flatbuffers::Vector<'a, u8> {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u8>>>(
                        Message::VT_DATA,
                        None,
                    )
                    .unwrap()
            }
        }
        pub fn data_nested_flatbuffer(&'a self) -> MessageData<'a> {
            let data = self.data();
            use flatbuffers::Follow;
            // Safety:
            // Created from a valid Table for this object
            // Which contains a valid flatbuffer in this slot
            unsafe { <flatbuffers::ForwardsUOffset<MessageData<'a>>>::follow(data.bytes(), 0) }
        }
        #[inline]
        pub fn hash(&self) -> flatbuffers::Vector<'a, u8> {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u8>>>(
                        Message::VT_HASH,
                        None,
                    )
                    .unwrap()
            }
        }
        #[inline]
        pub fn hash_scheme(&self) -> HashScheme {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<HashScheme>(Message::VT_HASH_SCHEME, Some(HashScheme::Blake3))
                    .unwrap()
            }
        }
        #[inline]
        pub fn signature(&self) -> flatbuffers::Vector<'a, u8> {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u8>>>(
                        Message::VT_SIGNATURE,
                        None,
                    )
                    .unwrap()
            }
        }
        #[inline]
        pub fn signature_scheme(&self) -> SignatureScheme {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<SignatureScheme>(
                        Message::VT_SIGNATURE_SCHEME,
                        Some(SignatureScheme::Ed25519),
                    )
                    .unwrap()
            }
        }
        #[inline]
        pub fn signer(&self) -> flatbuffers::Vector<'a, u8> {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u8>>>(
                        Message::VT_SIGNER,
                        None,
                    )
                    .unwrap()
            }
        }
    }

    impl flatbuffers::Verifiable for Message<'_> {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.visit_table(pos)?
                .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u8>>>(
                    "data",
                    Self::VT_DATA,
                    true,
                )?
                .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u8>>>(
                    "hash",
                    Self::VT_HASH,
                    true,
                )?
                .visit_field::<HashScheme>("hash_scheme", Self::VT_HASH_SCHEME, false)?
                .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u8>>>(
                    "signature",
                    Self::VT_SIGNATURE,
                    true,
                )?
                .visit_field::<SignatureScheme>(
                    "signature_scheme",
                    Self::VT_SIGNATURE_SCHEME,
                    false,
                )?
                .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u8>>>(
                    "signer",
                    Self::VT_SIGNER,
                    true,
                )?
                .finish();
            Ok(())
        }
    }
    pub struct MessageArgs<'a> {
        pub data: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u8>>>,
        pub hash: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u8>>>,
        pub hash_scheme: HashScheme,
        pub signature: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u8>>>,
        pub signature_scheme: SignatureScheme,
        pub signer: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u8>>>,
    }
    impl<'a> Default for MessageArgs<'a> {
        #[inline]
        fn default() -> Self {
            MessageArgs {
                data: None, // required field
                hash: None, // required field
                hash_scheme: HashScheme::Blake3,
                signature: None, // required field
                signature_scheme: SignatureScheme::Ed25519,
                signer: None, // required field
            }
        }
    }

    pub struct MessageBuilder<'a: 'b, 'b> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b> MessageBuilder<'a, 'b> {
        #[inline]
        pub fn add_data(&mut self, data: flatbuffers::WIPOffset<flatbuffers::Vector<'b, u8>>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<_>>(Message::VT_DATA, data);
        }
        #[inline]
        pub fn add_hash(&mut self, hash: flatbuffers::WIPOffset<flatbuffers::Vector<'b, u8>>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<_>>(Message::VT_HASH, hash);
        }
        #[inline]
        pub fn add_hash_scheme(&mut self, hash_scheme: HashScheme) {
            self.fbb_.push_slot::<HashScheme>(
                Message::VT_HASH_SCHEME,
                hash_scheme,
                HashScheme::Blake3,
            );
        }
        #[inline]
        pub fn add_signature(
            &mut self,
            signature: flatbuffers::WIPOffset<flatbuffers::Vector<'b, u8>>,
        ) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<_>>(Message::VT_SIGNATURE, signature);
        }
        #[inline]
        pub fn add_signature_scheme(&mut self, signature_scheme: SignatureScheme) {
            self.fbb_.push_slot::<SignatureScheme>(
                Message::VT_SIGNATURE_SCHEME,
                signature_scheme,
                SignatureScheme::Ed25519,
            );
        }
        #[inline]
        pub fn add_signer(&mut self, signer: flatbuffers::WIPOffset<flatbuffers::Vector<'b, u8>>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<_>>(Message::VT_SIGNER, signer);
        }
        #[inline]
        pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> MessageBuilder<'a, 'b> {
            let start = _fbb.start_table();
            MessageBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<Message<'a>> {
            let o = self.fbb_.end_table(self.start_);
            self.fbb_.required(o, Message::VT_DATA, "data");
            self.fbb_.required(o, Message::VT_HASH, "hash");
            self.fbb_.required(o, Message::VT_SIGNATURE, "signature");
            self.fbb_.required(o, Message::VT_SIGNER, "signer");
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl core::fmt::Debug for Message<'_> {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            let mut ds = f.debug_struct("Message");
            ds.field("data", &self.data());
            ds.field("hash", &self.hash());
            ds.field("hash_scheme", &self.hash_scheme());
            ds.field("signature", &self.signature());
            ds.field("signature_scheme", &self.signature_scheme());
            ds.field("signer", &self.signer());
            ds.finish()
        }
    }
    pub enum MessageBytesOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct MessageBytes<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for MessageBytes<'a> {
        type Inner = MessageBytes<'a>;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table::new(buf, loc),
            }
        }
    }

    impl<'a> MessageBytes<'a> {
        pub const VT_MESSAGE_BYTES: flatbuffers::VOffsetT = 4;

        #[inline]
        pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            MessageBytes { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
            args: &'args MessageBytesArgs<'args>,
        ) -> flatbuffers::WIPOffset<MessageBytes<'bldr>> {
            let mut builder = MessageBytesBuilder::new(_fbb);
            if let Some(x) = args.message_bytes {
                builder.add_message_bytes(x);
            }
            builder.finish()
        }

        #[inline]
        pub fn message_bytes(&self) -> flatbuffers::Vector<'a, u8> {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u8>>>(
                        MessageBytes::VT_MESSAGE_BYTES,
                        None,
                    )
                    .unwrap()
            }
        }
        pub fn message_bytes_nested_flatbuffer(&'a self) -> Message<'a> {
            let data = self.message_bytes();
            use flatbuffers::Follow;
            // Safety:
            // Created from a valid Table for this object
            // Which contains a valid flatbuffer in this slot
            unsafe { <flatbuffers::ForwardsUOffset<Message<'a>>>::follow(data.bytes(), 0) }
        }
    }

    impl flatbuffers::Verifiable for MessageBytes<'_> {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.visit_table(pos)?
                .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u8>>>(
                    "message_bytes",
                    Self::VT_MESSAGE_BYTES,
                    true,
                )?
                .finish();
            Ok(())
        }
    }
    pub struct MessageBytesArgs<'a> {
        pub message_bytes: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u8>>>,
    }
    impl<'a> Default for MessageBytesArgs<'a> {
        #[inline]
        fn default() -> Self {
            MessageBytesArgs {
                message_bytes: None, // required field
            }
        }
    }

    pub struct MessageBytesBuilder<'a: 'b, 'b> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b> MessageBytesBuilder<'a, 'b> {
        #[inline]
        pub fn add_message_bytes(
            &mut self,
            message_bytes: flatbuffers::WIPOffset<flatbuffers::Vector<'b, u8>>,
        ) {
            self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
                MessageBytes::VT_MESSAGE_BYTES,
                message_bytes,
            );
        }
        #[inline]
        pub fn new(
            _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        ) -> MessageBytesBuilder<'a, 'b> {
            let start = _fbb.start_table();
            MessageBytesBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<MessageBytes<'a>> {
            let o = self.fbb_.end_table(self.start_);
            self.fbb_
                .required(o, MessageBytes::VT_MESSAGE_BYTES, "message_bytes");
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl core::fmt::Debug for MessageBytes<'_> {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            let mut ds = f.debug_struct("MessageBytes");
            ds.field("message_bytes", &self.message_bytes());
            ds.finish()
        }
    }
    #[inline]
    /// Verifies that a buffer of bytes contains a `Message`
    /// and returns it.
    /// Note that verification is still experimental and may not
    /// catch every error, or be maximally performant. For the
    /// previous, unchecked, behavior use
    /// `root_as_message_unchecked`.
    pub fn root_as_message(buf: &[u8]) -> Result<Message, flatbuffers::InvalidFlatbuffer> {
        flatbuffers::root::<Message>(buf)
    }
    #[inline]
    /// Verifies that a buffer of bytes contains a size prefixed
    /// `Message` and returns it.
    /// Note that verification is still experimental and may not
    /// catch every error, or be maximally performant. For the
    /// previous, unchecked, behavior use
    /// `size_prefixed_root_as_message_unchecked`.
    pub fn size_prefixed_root_as_message(
        buf: &[u8],
    ) -> Result<Message, flatbuffers::InvalidFlatbuffer> {
        flatbuffers::size_prefixed_root::<Message>(buf)
    }
    #[inline]
    /// Verifies, with the given options, that a buffer of bytes
    /// contains a `Message` and returns it.
    /// Note that verification is still experimental and may not
    /// catch every error, or be maximally performant. For the
    /// previous, unchecked, behavior use
    /// `root_as_message_unchecked`.
    pub fn root_as_message_with_opts<'b, 'o>(
        opts: &'o flatbuffers::VerifierOptions,
        buf: &'b [u8],
    ) -> Result<Message<'b>, flatbuffers::InvalidFlatbuffer> {
        flatbuffers::root_with_opts::<Message<'b>>(opts, buf)
    }
    #[inline]
    /// Verifies, with the given verifier options, that a buffer of
    /// bytes contains a size prefixed `Message` and returns
    /// it. Note that verification is still experimental and may not
    /// catch every error, or be maximally performant. For the
    /// previous, unchecked, behavior use
    /// `root_as_message_unchecked`.
    pub fn size_prefixed_root_as_message_with_opts<'b, 'o>(
        opts: &'o flatbuffers::VerifierOptions,
        buf: &'b [u8],
    ) -> Result<Message<'b>, flatbuffers::InvalidFlatbuffer> {
        flatbuffers::size_prefixed_root_with_opts::<Message<'b>>(opts, buf)
    }
    #[inline]
    /// Assumes, without verification, that a buffer of bytes contains a Message and returns it.
    /// # Safety
    /// Callers must trust the given bytes do indeed contain a valid `Message`.
    pub unsafe fn root_as_message_unchecked(buf: &[u8]) -> Message {
        flatbuffers::root_unchecked::<Message>(buf)
    }
    #[inline]
    /// Assumes, without verification, that a buffer of bytes contains a size prefixed Message and returns it.
    /// # Safety
    /// Callers must trust the given bytes do indeed contain a valid size prefixed `Message`.
    pub unsafe fn size_prefixed_root_as_message_unchecked(buf: &[u8]) -> Message {
        flatbuffers::size_prefixed_root_unchecked::<Message>(buf)
    }
    #[inline]
    pub fn finish_message_buffer<'a, 'b>(
        fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        root: flatbuffers::WIPOffset<Message<'a>>,
    ) {
        fbb.finish(root, None);
    }

    #[inline]
    pub fn finish_size_prefixed_message_buffer<'a, 'b>(
        fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        root: flatbuffers::WIPOffset<Message<'a>>,
    ) {
        fbb.finish_size_prefixed(root, None);
    }
} // pub mod Farcaster
